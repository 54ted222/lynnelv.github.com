<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-11-05T14:34:21+08:00</updated><id>http://localhost:4000//</id><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">深入理解js事件循环机制（Node.js篇）</title><link href="http://localhost:4000/js-event-loop-nodejs" rel="alternate" type="text/html" title="深入理解js事件循环机制（Node.js篇）" /><published>2017-11-05T00:00:00+08:00</published><updated>2017-11-05T00:00:00+08:00</updated><id>http://localhost:4000/js-event-loop-nodejs</id><content type="html" xml:base="http://localhost:4000/js-event-loop-nodejs">&lt;style&gt;
	ol {
		list-style: decimal;
		list-style-position: inside;
	}
	blockquote p {
		text-indent: 0;
	}
    h2, h3 {
        font-weight: bold;
    }
    h2 {
        font-size: 1.2em;
        margin: .6em 0;
    }
    h3 {
        font-size: 1.1em;
        margin: .5em 0;
    }
&lt;/style&gt;

&lt;p&gt;在&lt;a href=&quot;http://lynnelv.github.io/js-event-loop-browser&quot;&gt;浏览器篇&lt;/a&gt;已经对事件循环机制和一些相关的概念作了详细介绍，但主要是针对浏览器端的研究，node环境是否也一样呢？先看一个demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;setTimeout(()=&amp;gt;{
    console.log('timer1')

    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)

setTimeout(()=&amp;gt;{
    console.log('timer2')

    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)

setTimeout(()=&amp;gt;{
    console.log('timer3')

    Promise.resolve().then(function() {
        console.log('promise3')
    })
}, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;肉眼编译运行一下，蒽，在浏览器的结果就是下面这个了，道理都懂，就不累述了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/browser-result.png&quot; alt=&quot;browser运行结果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么Node下执行看看，咦。。。奇怪，跟浏览器的运行结果并不一样~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/node-result.png&quot; alt=&quot;node运行结果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例子说明，浏览器和 Node.js 的事件循环机制是有区别的，一起来看个究竟吧~&lt;/p&gt;

&lt;h2 id=&quot;nodejs的事件处理&quot;&gt;Node.js的事件处理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt;采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现，&lt;a href=&quot;https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c#L348-L397&quot;&gt;核心源码参考&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;int uv_run(uv_loop_t* loop, uv_run_mode mode) {
  int timeout;
  int r;
  int ran_pending;

  r = uv__loop_alive(loop);
  if (!r)
    uv__update_time(loop);

  while (r != 0 &amp;amp;&amp;amp; loop-&amp;gt;stop_flag == 0) {
    uv__update_time(loop);
    // timers阶段
    uv__run_timers(loop);
    // I/O callbacks阶段
    ran_pending = uv__run_pending(loop);
    // idle阶段
    uv__run_idle(loop);
    // prepare阶段
    uv__run_prepare(loop);

    timeout = 0;
    if ((mode == UV_RUN_ONCE &amp;amp;&amp;amp; !ran_pending) || mode == UV_RUN_DEFAULT)
      timeout = uv_backend_timeout(loop);
    // poll阶段
    uv__io_poll(loop, timeout);
    // check阶段
    uv__run_check(loop);
    // close callbacks阶段
    uv__run_closing_handles(loop);

    if (mode == UV_RUN_ONCE) {
      uv__update_time(loop);
      uv__run_timers(loop);
    }

    r = uv__loop_alive(loop);
    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)
      break;
  }

  if (loop-&amp;gt;stop_flag != 0)
    loop-&amp;gt;stop_flag = 0;

  return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;Node.js&lt;/a&gt;官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/node-libuv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;timers 阶段&lt;/strong&gt;：这个阶段执行timer（&lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;）的回调&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;I/O callbacks 阶段&lt;/strong&gt;：执行一些系统调用错误，比如网络通信的错误回调&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;idle, prepare 阶段&lt;/strong&gt;：仅node内部使用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;poll 阶段&lt;/strong&gt;：获取新的I/O事件, 适当的条件下node将阻塞在这里&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;check 阶段&lt;/strong&gt;：执行 &lt;code&gt;setImmediate()&lt;/code&gt; 的回调&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;close callbacks 阶段&lt;/strong&gt;：执行 &lt;code&gt;socket&lt;/code&gt; 的 &lt;code&gt;close&lt;/code&gt; 事件回调&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们重点看&lt;code&gt;timers&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;check&lt;/code&gt;这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。&lt;/p&gt;

&lt;h3 id=&quot;timers-阶段&quot;&gt;timers 阶段&lt;/h3&gt;

&lt;p&gt;timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，&lt;code&gt;setTimeout()&lt;/code&gt; 和 &lt;code&gt;setImmediate()&lt;/code&gt; 的执行顺序是不确定的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;setTimeout(() =&amp;gt; {
  console.log('timeout')
}, 0)

setImmediate(() =&amp;gt; {
  console.log('immediate')
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是把它们放到一个I/O回调里面，就一定是 &lt;code&gt;setImmediate()&lt;/code&gt; 先执行，因为poll阶段后面就是check阶段。&lt;/p&gt;

&lt;h3 id=&quot;poll-阶段&quot;&gt;poll 阶段&lt;/h3&gt;

&lt;p&gt;poll 阶段主要有2个功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;处理 poll 队列的事件&lt;/li&gt;
  &lt;li&gt;当有已超时的 timer，执行它的回调函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的&lt;code&gt;setImmediate()&lt;/code&gt;，分两种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;若有预设的&lt;code&gt;setImmediate()&lt;/code&gt;, event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列&lt;/li&gt;
  &lt;li&gt;若没有预设的&lt;code&gt;setImmediate()&lt;/code&gt;，event loop将阻塞在该阶段等待&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意一个细节，没有&lt;code&gt;setImmediate()&lt;/code&gt;会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。&lt;/p&gt;

&lt;h3 id=&quot;check-阶段&quot;&gt;check 阶段&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;setImmediate()&lt;/code&gt;的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;event loop 的每个阶段都有一个任务队列&lt;/li&gt;
  &lt;li&gt;当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段&lt;/li&gt;
  &lt;li&gt;当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;讲得好有道理，可是没有demo我还是理解不全啊，憋急，now！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const fs = require('fs')

fs.readFile('test.txt', () =&amp;gt; {
  console.log('readFile')
  setTimeout(() =&amp;gt; {
    console.log('timeout')
  }, 0)
  setImmediate(() =&amp;gt; {
    console.log('immediate')
  })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果应该都没有疑问了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;readFile
immediate
timeout
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nodejs-与浏览器的-event-loop-差异&quot;&gt;Node.js 与浏览器的 Event Loop 差异&lt;/h2&gt;

&lt;p&gt;回顾上一篇，浏览器环境下，&lt;code&gt;microtask&lt;/code&gt;的任务队列是每个&lt;code&gt;macrotask&lt;/code&gt;执行完之后执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/ma(i)crotask.png&quot; alt=&quot;浏览器端&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在Node.js中，&lt;code&gt;microtask&lt;/code&gt;会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行&lt;code&gt;microtask&lt;/code&gt;队列的任务。
&lt;img src=&quot;../img/article/event-loop/ma(i)crotask-in-node.png&quot; alt=&quot;Node.js端&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;processnexttick-vs-setimmediate&quot;&gt;process.nextTick() VS setImmediate()&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;In essence, the names should be swapped. process.nextTick() fires more immediately than setImmediate()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;来自官方文档有意思的一句话，从语义角度看，&lt;code&gt;setImmediate()&lt;/code&gt; 应该比 &lt;code&gt;process.nextTick()&lt;/code&gt; 先执行才对，而事实相反，命名是历史原因也很难再变。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;process.nextTick()&lt;/code&gt; 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 &lt;code&gt;process.nextTick()&lt;/code&gt;，会导致出现I/O starving（饥饿）的问题，比如下面例子的readFile已经完成，但它的回调一直无法执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const fs = require('fs')
const starttime = Date.now()
let endtime

fs.readFile('text.txt', () =&amp;gt; {
  endtime = Date.now()
  console.log('finish reading time: ', endtime - starttime)
})

let index = 0

function handler () {
  if (index++ &amp;gt;= 1000) return
  console.log(`nextTick ${index}`)
  process.nextTick(handler)
  // console.log(`setImmediate ${index}`)
  // setImmediate(handler)
}

handler()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process.nextTick()&lt;/code&gt;的运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;nextTick 1
nextTick 2
......
nextTick 999
nextTick 1000
finish reading time: 170
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换成&lt;code&gt;setImmediate()&lt;/code&gt;，运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;setImmediate 1
setImmediate 2
finish reading time: 80
......
setImmediate 999
setImmediate 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为嵌套调用的 &lt;code&gt;setImmediate()&lt;/code&gt; 回调，被排到了下一次event loop才执行，所以不会出现阻塞。&lt;/p&gt;

&lt;h2 id=&quot;demo回顾&quot;&gt;demo回顾&lt;/h2&gt;

&lt;p&gt;综上所述，回顾文章最开始的demo，3个timer依次放入timer队列，主代码执行完，event loop开始；&lt;/p&gt;

&lt;p&gt;首先进入timers阶段，执行timer的回调函数，打印&lt;code&gt;timer1&lt;/code&gt;，并将promise1.then回调放入microtask队列，同样的步骤依次打印&lt;code&gt;timer2&lt;/code&gt;、&lt;code&gt;timer3&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;此时，poll队列执行完毕，&lt;code&gt;microtask&lt;/code&gt;队列的任务开始执行，依次打印&lt;code&gt;promise1&lt;/code&gt;、&lt;code&gt;promise2&lt;/code&gt;、&lt;code&gt;promise3&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Node.js 的事件循环分为6个阶段&lt;/li&gt;
  &lt;li&gt;浏览器和Node 环境下，&lt;code&gt;microtask&lt;/code&gt; 任务队列的执行时机不同
    &lt;ul&gt;
      &lt;li&gt;Node.js中，&lt;code&gt;microtask&lt;/code&gt; 在事件循环的各个阶段之间执行&lt;/li&gt;
      &lt;li&gt;浏览器端，&lt;code&gt;microtask&lt;/code&gt; 在事件循环的 &lt;code&gt;macrotask&lt;/code&gt; 执行完之后执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;递归的调用&lt;code&gt;process.nextTick()&lt;/code&gt;会导致I/O starving，官方推荐使用&lt;code&gt;setImmediate()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[参考资料]&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;event-loop-timers-and-nexttick&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cnodejs.org/topic/57d68794cb6f605d360105bf&quot;&gt;Node.js Event Loop 的理解 Timers，process.nextTick()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c&quot;&gt;libuv/core.c&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js&quot;&gt;nodejs/next_tick.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lynnelv.github.io/js-event-loop-browser&quot;&gt;深入理解js事件循环机制（浏览器篇）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="技术" /><category term="javascript" /><category term="eventloop" /><category term="Node.js" /><summary type="html">在上一篇已经介绍了事件循环机制和一些相关概念，但主要是针对浏览器端的研究，在Node.js环境是否也一样？本文会以Node.js为运行环境继续介绍。</summary></entry><entry><title type="html">深入理解js事件循环机制（浏览器篇）</title><link href="http://localhost:4000/js-event-loop-browser" rel="alternate" type="text/html" title="深入理解js事件循环机制（浏览器篇）" /><published>2017-11-04T00:00:00+08:00</published><updated>2017-11-04T00:00:00+08:00</updated><id>http://localhost:4000/js-event-loop-browser</id><content type="html" xml:base="http://localhost:4000/js-event-loop-browser">&lt;style&gt;
	ol {
		list-style: decimal;
		list-style-position: inside;
	}
	blockquote p {
		text-indent: 0;
	}
    h2, h3 {
        font-weight: bold;
    }
    h2 {
        font-size: 1.2em;
        margin: .6em 0;
    }
    h3 {
        font-size: 1.1em;
        margin: .5em 0;
    }
&lt;/style&gt;

&lt;h2 id=&quot;抛在前面的问题&quot;&gt;抛在前面的问题：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;单线程如何做到异步&lt;/li&gt;
  &lt;li&gt;事件循环的过程是怎样的&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;macrotask&lt;/code&gt; 和 &lt;code&gt;microtask&lt;/code&gt; 是什么，它们有何区别&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;单线程和异步&quot;&gt;单线程和异步&lt;/h3&gt;

&lt;p&gt;提到js，就会想到&lt;strong&gt;单线程&lt;/strong&gt;，&lt;strong&gt;异步&lt;/strong&gt;，那么单线程是如何做到异步的呢？概念先行，先要了解下单线程和异步之间的关系。&lt;/p&gt;

&lt;p&gt;js的任务分为 &lt;em&gt;同步&lt;/em&gt; 和 &lt;em&gt;异步&lt;/em&gt; 两种，它们的处理方式也不同，&lt;strong&gt;同步任务&lt;/strong&gt;是直接在主线程上排队执行，&lt;strong&gt;异步任务&lt;/strong&gt;则会被放到任务队列中，若有多个任务（异步任务）则要在任务队列中排队等待，任务队列类似一个缓冲区，任务下一步会被移到&lt;strong&gt;调用栈&lt;/strong&gt;（call stack），然后主线程执行调用栈的任务。&lt;/p&gt;

&lt;p&gt;单线程是指js引擎中负责解析执行js代码的线程只有一个（&lt;strong&gt;主线程&lt;/strong&gt;），即每次只能做一件事，而我们知道一个ajax请求，主线程在等待它响应的同时是会去做其它事的，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。&lt;/p&gt;

&lt;p&gt;总而言之，检查调用栈是否为空，以及确定把哪个task加入调用栈的这个过程就是&lt;strong&gt;事件循环&lt;/strong&gt;，而&lt;strong&gt;js实现异步的核心就是事件循环&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;调用栈和任务队列&quot;&gt;调用栈和任务队列&lt;/h3&gt;

&lt;p&gt;顾名思义，调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。&lt;/p&gt;

&lt;p&gt;下图就是调用栈和任务队列的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/callstack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;事件循环&quot;&gt;事件循环&lt;/h3&gt;

&lt;p&gt;关于事件循环，&lt;a href=&quot;https://www.w3.org/TR/html5/webappapis.html#event-loop&quot;&gt;HTML规范&lt;/a&gt;的介绍&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;There must be at least one event loop per user agent, and at most one event loop per unit of related similar-origin browsing contexts.&lt;br /&gt;An event loop has one or more task queues.&lt;br /&gt;Each task is defined as coming from a specific task source.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从规范理解，浏览器至少有一个事件循环，一个事件循环至少有一个任务队列（macrotask），每个外任务都有自己的分组，浏览器会为不同的任务组设置优先级。&lt;/p&gt;

&lt;h3 id=&quot;macrotask--microtask&quot;&gt;macrotask &amp;amp; microtask&lt;/h3&gt;

&lt;p&gt;规范有提到两个概念，但没有详细介绍，查阅一些资料大概可总结如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;macrotask&lt;/strong&gt;：包含执行整体的js代码，事件回调，XHR回调，定时器（setTimeout/setInterval/setImmediate），IO操作，UI render&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;microtask&lt;/strong&gt;：更新应用程序状态的任务，包括promise回调，MutationObserver，process.nextTick，Object.observe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中&lt;code&gt;setImmediate&lt;/code&gt;和&lt;code&gt;process.nextTick&lt;/code&gt;是nodejs的实现，在&lt;a href=&quot;http://lynnelv.github.io/js-event-loop-nodejs&quot;&gt;nodejs篇&lt;/a&gt;会详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;事件处理过程&quot;&gt;事件处理过程&lt;/h3&gt;

&lt;p&gt;关于&lt;code&gt;macrotask&lt;/code&gt;和&lt;code&gt;microtask&lt;/code&gt;的理解，光这样看会有些晦涩难懂，结合事件循坏的机制理解清晰很多，下面这张图可以说是介绍得非常清楚了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/event-loop.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结起来，一次事件循环的步骤包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 检查macrotask队列是否为空，非空则到2，为空则到3
2. 执行macrotask中的一个任务
3. 继续检查microtask队列是否为空，若有则到4，否则到5
4. 取出microtask中的任务执行，执行完成返回到步骤3
5. 执行视图更新
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mactotask--microtask的执行顺序&quot;&gt;mactotask &amp;amp; microtask的执行顺序&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/ma(i)crotask.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;读完这么多干巴巴的概念介绍，还不如看一段代码感受下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log('start')

setTimeout(function() {
  console.log('setTimeout')
}, 0)

Promise.resolve().then(function() {
  console.log('promise1')
}).then(function() {
  console.log('promise2')
})

console.log('end')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印台输出的log顺序是什么？结合上述的步骤分析，系不系so easy~&lt;/p&gt;

&lt;p&gt;首先，js代码被放到调用栈执行，打印&lt;code&gt;start&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;遇到setTimeout，压入macrotask队列，往下执行把promise.then回调压入microtask队列，最后执行console.log(‘end’)，打印出&lt;code&gt;end&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;至此，调用栈中的代码被执行完成，回顾macrotask的定义，我们知道整体代码属于macrotask，macrotask执行完，那接下来就是执行microtask队列的任务了，执行promise回调打印&lt;code&gt;promise1&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;promise回调函数默认返回undefined，promise状态变为fullfill触发接下来的then回调，继续压入microtask队列，&lt;strong&gt;event loop会把当前的microtask队列一直执行完&lt;/strong&gt;，此时执行第二个promise.then回调打印出&lt;code&gt;promise2&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;这时microtask队列已经为空，从上面的流程图可以知道，接下来主线程会去做一些UI渲染工作（不一定会做），之后再继续下一次事件处理，取出macrotask中的setTimeout回调执行，打印出&lt;code&gt;setTimeout&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;这个过程会不断重复，也就是所谓的&lt;strong&gt;事件循环&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;视图渲染的时机&quot;&gt;视图渲染的时机&lt;/h3&gt;

&lt;p&gt;回顾上面的事件循环示意图，update rendering（视图渲染）发生在本轮事件循环的microtask队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒60帧（60fps）的速率刷新页面，据说这个帧率最适合人眼交互，大概16.7ms渲染一帧，所以如果要让用户觉得顺畅，单个macrotask及它相关的所有microtask最好能在16.7ms内完成。&lt;/p&gt;

&lt;p&gt;但也不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略，例如把几次的视图更新累积到一起重绘，重绘之前会通知requestAnimationFrame执行回调函数，也就是说requestAnimationFrame回调的执行时机是在一次或多次事件循环的UI render阶段。&lt;/p&gt;

&lt;p&gt;以下代码可以验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;setTimeout(function() {console.log('timer1')}, 0)

requestAnimationFrame(function(){
	console.log('requestAnimationFrame')
})

setTimeout(function() {console.log('timer2')}, 0)

new Promise(function executor(resolve) {
	console.log('promise 1')
	resolve()
	console.log('promise 2')
}).then(function() {
	console.log('promise then')
})

console.log('end')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果截图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/event-loop/requestAnimationFrame-run-result1.png&quot; alt=&quot;运行结果1&quot; /&gt;
&lt;img src=&quot;../img/article/event-loop/requestAnimationFrame-run-result2.png&quot; alt=&quot;运行结果2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，结果1中&lt;code&gt;requestAnimationFrame()&lt;/code&gt;是在一次事件循环后执行，而在结果2，它的执行则是在三次事件循环结束后。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;事件循环是js实现异步的核心&lt;/li&gt;
  &lt;li&gt;每轮事件循环分为3个步骤：
    &lt;blockquote&gt;
      &lt;p&gt;a) 执行macrotask队列的一个任务&lt;br /&gt;
b) 执行完当前microtask队列的所有任务&lt;br /&gt;
c) UI render&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[参考资料]&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/html5/webappapis.html#event-loops&quot;&gt;event-loops&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues&quot;&gt;sec-jobs-and-job-queues&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://promisesaplus.com/#notes&quot;&gt;Promises/A+&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&amp;amp;utm_medium=email&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24460769&quot;&gt;HTML系列：macrotask和microtask&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&quot;&gt;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="技术" /><category term="javascript" /><category term="eventloop" /><summary type="html">众所周知js是单线程语言，却可以很好的处理多个异步请求，其中的运行机制是怎样的呢？浏览器和nodejs的处理方式是一样的吗？</summary></entry><entry><title type="html">灰色花莲（完结）</title><link href="http://localhost:4000/trip-of-hualian" rel="alternate" type="text/html" title="灰色花莲（完结）" /><published>2017-10-21T00:00:00+08:00</published><updated>2017-10-21T00:00:00+08:00</updated><id>http://localhost:4000/trip-of-taiwan-hualian</id><content type="html" xml:base="http://localhost:4000/trip-of-hualian">&lt;p&gt;花莲是这次台湾行的最后一站，从枋寮坐台铁5个小时左右过去，花莲于我是灰色的，因为台风的缘故，从抵达直到回去，总共三天都在下豪雨，天空灰蒙蒙的，所以之前的行程计划也只能跟着搁浅了，即使这样，还是冒雨去了七星潭，清水断崖没有去成，很大一部分时间都在找各种推荐吃的店。&lt;/p&gt;

&lt;p&gt;枋寮只是屏东的一个乡，小而干净的火车站，壁上还有余光中的车过枋寮。
&lt;img src=&quot;../img/article/taiwan/fangliao-station.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到花莲已经差不多下午6点了，看到这天色，脑子闪过周董的一句歌词：天空灰得像哭过。果然这架势憋不久了，等公交的时候，忽然瓢泼大雨，伞根本不管用，还拖着个行李箱，雨中狼狈，整个人的心情都不好了。&lt;/p&gt;

&lt;p&gt;台湾的夜市文化，体现就是每个地方都有自己的夜市，来台湾的必修课少不了逛夜市，花莲这边的是自强夜市，因为天气的关系，玩不了只能靠吃好吃的来弥补萎靡的心情了，基本把一些网上推荐的店都吃了一遍。&lt;/p&gt;

&lt;p&gt;这家包子店在当地很火，游客心态就是免不了要凑热闹，我觉得味道不如名声。
&lt;img src=&quot;../img/article/taiwan/bread-shop.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;海蛎煎，小小的店面，却很多人排着队等，门口挂着：人手不够，只提供外带。打包了一份，味道并不惊艳。
&lt;img src=&quot;../img/article/taiwan/hailijian.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有连夜冒着暴风雨去吃的芋圆，服务员端来一个手掌般大小碟子装的芋圆和一大碗冰沙，告诉我一颗芋圆配一口冰沙吃，讶异到哭笑不得，不是应该薄薄的冰沙下面铺一层厚厚的芋圆才对吗。。。其实前一天晚上在隔壁家吃了，当下觉得也就那样，后来看到马蜂窝上有人说它隔壁那家才是正宗的，就又专程跑过来，这就是我风雨兼程来吃的芋圆吗？！混蛋啊！
&lt;img src=&quot;../img/article/taiwan/sorbet.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本来想着第二天放晴的话就去清水断崖和七星潭，想得美了，还是暴雨，可一想到大老远跑过来，就为了住两晚酒店吗？总得去一个！那清水断崖比较远就算了，去七星潭吧。还是不枉跑一趟的，即使没有蓝天白云，看层层浪卷拍岸也很赏心悦目。
&lt;img src=&quot;../img/article/taiwan/qixing-lake.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;游客照 of 摆石头。
&lt;img src=&quot;../img/article/taiwan/stone-of-qixing-lake.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上，此次台湾行的一些流水日记，主要是给以后的自己看，或许还能依照字句记起当时的一些feel。每天两点一线的机械生活很容易让人麻木，内心的小人偶尔也会出来挣扎：“这不是你想要的生活！”，可是我怂，一直在幻想某天会有个人拉上我，“走！我们一起去找你想要的生活！”，在我变洒脱到可以不顾一切之前，先这样蛰着吧，每年至少给自己一次出去放空的机会，释放掉堆积的情绪，然后遇见更好一点的自己。&lt;/p&gt;</content><category term="旅行" /><category term="旅行" /><category term="台湾" /><summary type="html">花莲于我是灰色的，因为台风的缘故，从抵达直到回去，全程都在下豪雨。</summary></entry><entry><title type="html">蓝色垦丁（三）</title><link href="http://localhost:4000/trip-of-kending" rel="alternate" type="text/html" title="蓝色垦丁（三）" /><published>2017-10-16T00:00:00+08:00</published><updated>2017-10-16T00:00:00+08:00</updated><id>http://localhost:4000/trip-of-taiwan-kending</id><content type="html" xml:base="http://localhost:4000/trip-of-kending">&lt;p&gt;其实垦丁才是此行的重点，早在朋友圈微博就领略过了垦丁蓝，果然不虚此行，待了5天4晚，垦丁的天气变脸比翻书还快，有3天都在下雨，这点略可惜，幸好后面放晴了，才有下面碧海蓝天的照片。&lt;/p&gt;

&lt;p&gt;垦丁没有火车站，所以只能从台北坐火车先到左营，再转班车，一上班车司机就说，今天垦丁暴雨路上很堵哦，你们先要有心理准备，本来还蛮担心会塞到晕车，但其实路况还好，台湾人好像都脾气很好，一般客车司机脾气都会比较急躁，在这边也待了有11天，发现他们完全不会，还会跟乘客讲玩笑，软软的台湾腔，好想知道他们是怎么吵架的，哈哈。&lt;/p&gt;

&lt;p&gt;到垦丁大街已经7点多了，还好第一晚的住宿定在垦丁大街，可以不用赶时间，放好行李再下去吃吃吃，个人觉得比士林夜市好多了。&lt;/p&gt;

&lt;p&gt;不过照样是暴雨+人多到爆，这张是10号拍的，已经过了人潮期。
&lt;img src=&quot;../img/article/taiwan/kending-street.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一晚都在吃各种小吃，没有去点菜吃饭。
&lt;img src=&quot;../img/article/taiwan/banana.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/octopus_balls.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后面三天住在船帆石附近，因为天气的原因，后面2天才开始计划玩的事，第二天骑小电驴兜了漂亮的东线，真的很美，随手一张都是壁纸。&lt;/p&gt;

&lt;p&gt;小阳台的视角很棒，对面就是船帆石，白天可以看碧海蓝天，晚上吹着徐徐海风，喝着啤酒看剧简直不要太惬意，喜欢这种慢慢的生活节奏。
&lt;img src=&quot;../img/article/taiwan/balcony.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/chuanfanshi.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;阳台，海风，零食，千与千寻。
&lt;img src=&quot;../img/article/taiwan/balcony_at_night.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;美腻的东线，右边是海，有一段左边是绿油油的草地，风很大，后视镜沿途都是摇曳的芦苇。
&lt;img src=&quot;../img/article/taiwan/coast_highway.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/coast_highway1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/grassland.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/stone.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一路骑到最南点。
&lt;img src=&quot;../img/article/taiwan/beacon.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/southernmost_point_of_taiwan.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第三天去了南湾玩水上项目，上次去马来浮浅套餐和装备都准备好了，无奈姨妈造访，没得玩到，这次终于可以玩了，然而却怕水怂了，只敢在够得着船绳的地方活动，待了10分钟不到就感觉不适放弃了，海水的透明度一般，鱼也不多，可能深潜会好很多。香蕉船和摇摆船不错，浪再大点应该更爽。下午涨潮浪还挺大，很多老外在冲浪，超帅的，看得我好羡慕，想到我那学了2个夏天还没学会的游泳，明年一定要啃下！我也好想潜水，冲浪，滑雪，跳伞，蹦极！！30岁之前的flag！！！
&lt;img src=&quot;../img/article/taiwan/beach.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了拍浪，手机差点被扑。
&lt;img src=&quot;../img/article/taiwan/waves.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/waves1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/sunset.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/play-in-sunset.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;真的很美！表白垦丁蓝！maybe以后我会再来一次。&lt;/p&gt;</content><category term="旅行" /><category term="旅行" /><category term="台湾" /><summary type="html">其实垦丁才是此行的重点，早在朋友圈微博就领略过了垦丁蓝，果然不虚此行。</summary></entry><entry><title type="html">橘色九份（二）</title><link href="http://localhost:4000/trip-of-jiufen" rel="alternate" type="text/html" title="橘色九份（二）" /><published>2017-10-15T00:00:00+08:00</published><updated>2017-10-15T00:00:00+08:00</updated><id>http://localhost:4000/trip-of-taiwan-jiufen</id><content type="html" xml:base="http://localhost:4000/trip-of-jiufen">&lt;p&gt;据说九份是《千与千寻》的原型，这部作为个人最喜欢的日漫，既然是它的原型，当然想去see see了。但是晚上才是九份最nice的时候，索性就把行李寄存在火车站，白天沿着瑞芳线玩，真的是经（拥）典（挤）观光线啊。。。每一站都塞到爆！所以只在平溪和十分下站去转，奈何天公不作美，豪雨不停，本来去十分放天灯的想法泡汤了。
&lt;img src=&quot;../img/article/taiwan/shifen.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坐台铁当然要吃台铁便当，80台币一份，秒杀国铁4 5十的盒饭！
&lt;img src=&quot;../img/article/taiwan/bento.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;落夜前，折返瑞芳，拿了行李，前往九份之前预定的民宿，这次除了在台北住酒店，其他城市都是选择了当地民宿，国庆是出行高峰期，加上住宿也是出发前一周才去定，所以价格略高了，整体下来基本每晚在600RMB左右了。所以咧，旅行这件事，还是要提早计划行程性价比才高。&lt;/p&gt;

&lt;p&gt;这就是网红店，阿妹茶楼啦，只是茶楼，没有点菜只有喝茶~
&lt;img src=&quot;../img/article/taiwan/jiufen-amei.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看蚂蜂窝的推荐，尝了一家芋圆，味道不错，芋圆能吃出芋头和番薯的味道，对于一枚吃货而言，没什么比带我吃好吃的更开心啦。
&lt;img src=&quot;../img/article/taiwan/jiufen-street.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在九份待一天完全足够了，主要是逛九份老街，观赏夜景，第二天启程南下垦丁。&lt;/p&gt;

&lt;p&gt;来自等车时的一张随手拍，早上的山城，雾色弥漫，跟晚上的一片金橘对比，又是另一番景象。
&lt;img src=&quot;../img/article/taiwan/day-of-jiufen.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;</content><category term="旅行" /><category term="旅行" /><category term="台湾" /><summary type="html">据说九份是《千与千寻》的原型，这部作为个人最喜欢的日漫，它的原型当然想去cc了。</summary></entry><entry><title type="html">绿色台北（一）</title><link href="http://localhost:4000/trip-of-taibei" rel="alternate" type="text/html" title="绿色台北（一）" /><published>2017-10-14T00:00:00+08:00</published><updated>2017-10-14T00:00:00+08:00</updated><id>http://localhost:4000/trip-of-taiwan-taibei</id><content type="html" xml:base="http://localhost:4000/trip-of-taibei">&lt;blockquote&gt;
  &lt;p&gt;day 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实年后就在谋划台湾之行了，免不了的是各种复杂的证件，因为户籍所在城市没有在台湾自由行开放城市的list中，所以只能先在深圳办理居住证，才办台湾通行证。&lt;/p&gt;

&lt;p&gt;顺着国庆休了5天年假，大半个月的时间了，个人很不喜欢压迫的行程，错开头三天的出行高峰期，4号才出发，从澳门飞，还顺道去赌输了200块、、(╥_╥)  抵达台北已经是下午6点多，办理完出境之后先去买了悠游卡，地铁的服务小哥蛮帅也热心帮忙，道谢后，暖绵绵的台湾腔说到“不会”，哈哈，（不会=不用谢）蛮特别的喔。&lt;/p&gt;

&lt;p&gt;飞机上拍的台北夜景
&lt;img src=&quot;../img/article/taiwan/taibei-night-view-in-plane.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坐了一个多小时的地铁，累饿交加，到酒店checkin之后，赶紧出去觅食，转到了离酒店不远传说中的西门町，感觉跟深圳的东门差不多啊。&lt;/p&gt;

&lt;p&gt;机车贯行的街道，绿灯一亮，很大的轰隆隆发动机声音，有种赛车的画面感，很不一样的景象。
&lt;img src=&quot;../img/article/taiwan/autobike.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;day 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二天预约了傍晚的猫缆，超多人排队，上去问才知道，原来5:30之后排队买票很优惠，来回才120台币，马上加入排队阵容，心得就是超抵的，缆车上看夕阳很赞。
&lt;img src=&quot;../img/article/taiwan/sunset-in-cable.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/sunset-in-cable1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;day 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;戒不掉早上赖床的习惯，基本每天都是中午过后才出门，所以时间会比较紧，不过还是去了中正纪念堂和博物馆。&lt;/p&gt;

&lt;p&gt;在中正纪念堂，参观了蒋公的文物，发现原来蒋友柏帅是有道理的，也刚好碰上他们的交接仪式。
&lt;img src=&quot;../img/article/taiwan/jiangjieshi.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为临近双10，台湾的国庆日，在自由广场前面可以看到他们在准备演练，天气很好，天蓝蓝的，怎么拍都好看。
&lt;img src=&quot;../img/article/taiwan/free-square.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;老实讲，我对故宫、博物馆这些是不感冒的，抱着来都来了的心态，出奇发现故宫博物馆还蛮多有意思的东西。&lt;/p&gt;

&lt;p&gt;这颗白菜算是镇馆宝？人挤人围观拍照。。。
&lt;img src=&quot;../img/article/taiwan/cabbage.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很多艺术品做工非常精致，感叹古人的技艺，真是巧夺天工，惊艳到了。
&lt;img src=&quot;../img/article/taiwan/artwork.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/artwork1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;逛完博物馆，也到了饭点，来台湾免不了要光顾的夜市还没去，于是查好路线，兴致勃勃的去坐公交，等公交的时候，忽然瓢泼大雨，也没有带伞，失落归失落，一想到那么多好吃的在跟我招手，嘻嘻，吃货的心是阻挡不了的，下公交即刻跑去711买雨衣穿好就开始逛夜市。人很多，大家都在吃吃吃，可能是期待太高，有点失落，吃的来来去去就那几样，环境不太好，地沟油的感觉，发现他们很中意油炸、烧烤的食物，基本小吃都是这一类。
&lt;img src=&quot;../img/article/taiwan/shilin-market.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/shilin-market1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/shilin-market2.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个鸡排超级大块，基本半只鸡了。
&lt;img src=&quot;../img/article/taiwan/chicken-chop.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有我心心念念的牛肉面，找了几家推荐的，打算都试一遍，计划永远赶不上变化，有一家去排了2次队也没吃上，康熙推荐的那家特意在坐台铁前的等车空隙，打车过去吃，被告知休息日不开门，司机都要被我的执著感动了，还好有一家没白跑，总算吃上了，牛肉炖得刚好，汤也好喝，240台币一碗。
&lt;img src=&quot;../img/article/taiwan/beef_noodles.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;早在微博上就看到台北101的一个放烟火庆祝新年的视频，很赞，这次当然要来膜拜下，观光客真是多到可怕，其中很多韩国人，苦苦排了2个小时的队终于买到了观光票，所谓的观赏夜景，就是上去拍照证明自己来过，待了20分钟不到就被要求下去了(,,Ծ‸Ծ,, )，有点不爽，反正不会再有第二次了。（PS：为什么title讲台北是绿色，因为当天的101颜色。）
&lt;img src=&quot;../img/article/taiwan/101.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/night-view-101.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/article/taiwan/night-view-of-101.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总体来讲，台北给我的印象还不错，民风淳朴，不过互联网普及程度确实不如大陆，吃饭排位还是传统的服务员记号，支付也基本是现金交易，支付宝在海外推广力度很大，在711、全家都有满减活动，相比之下，基本都没有看到微信的影子。台湾腔听起来很温暖（哈哈，没有对比就没有伤害，天天被叫阿姨的人，在台湾可以享受“妹妹”的称呼），人也nice。&lt;/p&gt;</content><category term="旅行" /><category term="旅行" /><category term="台湾" /><summary type="html">从小追看的各种台剧，有种淳朴却不失小清新的画面感，早就想去台湾看看了，寻找旧旧的感觉。</summary></entry><entry><title type="html">兼容安卓、IOS的纯数字键盘输入方案</title><link href="http://localhost:4000/only-number-input" rel="alternate" type="text/html" title="兼容安卓、IOS的纯数字键盘输入方案" /><published>2017-06-15T00:00:00+08:00</published><updated>2017-06-15T00:00:00+08:00</updated><id>http://localhost:4000/only-number-input</id><content type="html" xml:base="http://localhost:4000/only-number-input">&lt;b&gt;需求点：&lt;/b&gt;
&lt;p&gt;
1、调起系统的数字键盘。2、只接受0-9的数字输入。3、限制输入长度是18。
&lt;/p&gt;
&lt;b&gt;踩在前面的坑：&lt;/b&gt;
&lt;p&gt;
	提到纯数字输入，自然而然的反应就是number类型的input控件，但它在IOS下并不能调起数字键盘。
&lt;/p&gt;
&lt;p&gt;
	于是又想到了&lt;code&gt;pattern&lt;/code&gt;属性，加了&lt;code&gt;pattern=&quot;\d*&quot;&lt;/code&gt;之后（PS:\d{18}不OK），安卓、IOS都能正常拉起数字键盘了，但是问题又来了，安卓下的数字键盘是带运算符（+、-、.）的，因为这几个符号（包括e）属于数字范畴。
&lt;/p&gt;
&lt;p&gt;
	o(︶︿︶)o。。。不能限制它不现实运算符，但我能去清掉你们吧，清掉的方法其实很简单&lt;code&gt;onkeypress=&quot;if(event.keyCode &lt; 48 || event.keyCode &gt; 56) event.returnValue = false;&quot;&lt;/code&gt;
&lt;/p&gt;
&lt;p&gt;
	PC下效果完美，然而安卓和IOS表现各异，安卓下不触发keypress，IOS不触发keyup，且安卓下的keyup也不能禁止运算符的输入。
&lt;/p&gt;
&lt;p&gt;
	最后，看了下别人的手机充值代码，用了tel类型，代替number+pattern调起数字键盘，至于禁止前面说的运算符，监听keyup事件去掉非数字字符就可以了，我用的是vue，这步放在watch里面。&lt;br /&gt;
&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	watch: {
		id: function(val, old) {
			if (old !== val) {
				this.id = this.getNum(val)
			}
		}
	},
	methods: {
		getNum(value) {
			return this.$util.trim(value).replace(/[^\d]/g, '')
		}
	}
	&lt;/code&gt;
&lt;/pre&gt;&lt;br /&gt;
开发中很小的一个问题，纯当吐槽记の。</content><category term="技术" /><category term="html" /><category term="javascript" /><summary type="html">兼容安卓、IOS的纯数字键盘输入方案，限制只输入0-9的数字。</summary></entry><entry><title type="html">歌单『周杰伦』</title><link href="http://localhost:4000/jaychou" rel="alternate" type="text/html" title="歌单『周杰伦』" /><published>2017-05-23T00:00:00+08:00</published><updated>2017-05-23T00:00:00+08:00</updated><id>http://localhost:4000/jaychou</id><content type="html" xml:base="http://localhost:4000/jaychou">陪我走过一整个青春的歌，就算再失落难过，听周杰伦总能让我静心下来，记給我自己。&lt;br&gt;
&lt;iframe id=&quot;music-box&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot;&gt;&lt;/iframe&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	window.addEventListener('DOMContentLoaded', () =&gt; {
		let iframe = document.querySelector('#music-box')
		if (x &lt;= 520) {
			iframe.src = '//music.163.com/outchain/player?type=0&amp;id=737659339&amp;auto=0&amp;height=90'
			iframe.width = 320 + 'px'
		} else {
			iframe.src = '//music.163.com/outchain/player?type=0&amp;id=737659339&amp;auto=0&amp;height=430'
			iframe.width = 600 + 'px'
			iframe.height  = y + 'px'
		}
	})
&lt;/script&gt;</content><category term="音乐" /><category term="歌单" /><category term="周杰伦" /><category term="青春" /><summary type="html">陪我走过一整个青春的歌，就算再失落难过，听周杰伦总能让我静心下来。</summary></entry><entry><title type="html">记jmeter常用功能</title><link href="http://localhost:4000/jmeter" rel="alternate" type="text/html" title="记jmeter常用功能" /><published>2017-05-11T00:00:00+08:00</published><updated>2017-05-11T00:00:00+08:00</updated><id>http://localhost:4000/jmeter</id><content type="html" xml:base="http://localhost:4000/jmeter">&lt;p&gt;
	前段时间，哦，不，应该说是前几个月，研究了下测试工具jmeter的使用。时隔已久，今天临时需要测试一批接口的返回码，自然想起了用jmeter啊，但是发现有些用法不太记得了。。。故翻以前的笔记整理一下，记之。
&lt;/p&gt;
&lt;p&gt;
	关于jmeter的介绍就不多说了（其实是我也没有很熟悉它），安装很简单，依赖java环境，蒽，自然可以跨平台使用。jmeter操作步骤基本是：创建一个测试计划，配置，执行测试计划，然后分析结果。
&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
		&lt;dl&gt;
			&lt;dt&gt;1. 添加测试计划&lt;/dt&gt;
			&lt;dd&gt;
				&lt;img src=&quot;../img/article/jmeter/test-plan.png&quot;&gt;
				&lt;p&gt;这里设置的是全局变量，能在整个测试plan访问到。&lt;/p&gt;
			&lt;/dd&gt;
		&lt;/dl&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;dl&gt;
			&lt;dt&gt;2. 添加线程组&lt;/dt&gt;
			&lt;dd&gt;
				&lt;ul&gt;
					&lt;li&gt;线程数：执行测试计划的线程数。&lt;/li&gt;
					&lt;li&gt;ramp-up period：启动所有线程的耗时，如线程数是100，启动时长设置10，则1s启动10个线程。&lt;/li&gt;
					&lt;li&gt;循环次数：单线程发送请求的次数，如线程数是100，循环10次，则总请求数等于1000。&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/dd&gt;
		&lt;/dl&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;dl&gt;
			&lt;dt&gt;3. 添加配置元件&lt;/dt&gt;
			&lt;dd&gt;
				&lt;p&gt;
					&lt;b&gt;http请求默认值&lt;/b&gt;：默认所有请求都自动带上所设置的参数。
				&lt;/p&gt;
				&lt;img src=&quot;../img/article/jmeter/default-param.png&quot;&gt;
			&lt;/dd&gt;
		&lt;/dl&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;dl&gt;
			&lt;dt&gt;4. 后置处理器&lt;/dt&gt;
			&lt;ul&gt;
				&lt;li&gt;
					&lt;dl&gt;
						&lt;dt&gt;正则提取器：&lt;/dt&gt;
						&lt;dd&gt;
							提取返回结果作为下一个请求的入参。
							&lt;img src=&quot;../img/article/jmeter/regex-extractor.png&quot;&gt;
							&lt;p class=&quot;warn-text&quot;&gt;如果提取结果是一个数组，需要自动循环下个请求，这时候就要配合forEach控制器使用。&lt;/p&gt;
							&lt;p&gt;&lt;b&gt;loop start index&lt;/b&gt;: 1&lt;/p&gt;
							&lt;p&gt;&lt;b&gt;loop end index&lt;/b&gt;: &lt;code&gt;${id_arr_matchNr}&lt;/code&gt;&lt;/p&gt;
							&lt;p&gt;&lt;b&gt;loop variable&lt;/b&gt;: id&lt;/p&gt;
							&lt;img src=&quot;../img/article/jmeter/foreach.png&quot;&gt;
							&lt;p&gt;
								其中result为上个请求的返回结果集，下个请求通过&lt;code&gt;${id}&lt;/code&gt;引用单个结果。
							&lt;/p&gt;
							&lt;img src=&quot;../img/article/jmeter/next-req.png&quot;&gt;
						&lt;/dd&gt;
					&lt;/dl&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/dl&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;dl&gt;
			&lt;dt&gt;5. 监听器&lt;/dt&gt;
			&lt;dd&gt;
				&lt;ul&gt;
					&lt;li&gt;
						&lt;dl&gt;
							&lt;dt&gt;察看结果树：&lt;/dt&gt;
							&lt;dd&gt;
								查看每个请求的详细情况。
							&lt;/dd&gt;
							&lt;img src=&quot;../img/article/jmeter/graphic.png&quot;&gt;
						&lt;/dl&gt;
					&lt;/li&gt;
					&lt;li&gt;
						&lt;dt&gt;PerfMon Metrics Collectot：&lt;/dt&gt;
						&lt;dd&gt;
							监控server的CPU、内存等指标，指定端口监听：&lt;br&gt;
							&lt;code&gt;java -jar ./CMDRunner.jar --tool PerfMonAgent --udp-port 8080 --tcp-port 8080&lt;/code&gt;
							&lt;img src=&quot;../img/article/jmeter/perfmon.png&quot;&gt;
						&lt;/dd&gt;
					&lt;/li&gt;
					&lt;li&gt;
						&lt;dt&gt;聚合报告：&lt;/dt&gt;
						&lt;dd&gt;
							&lt;img src=&quot;../img/article/jmeter/poly-report.png&quot;&gt;
							&lt;p&gt;- Label: 展示测试过程中所有执行的请求和控制器的聚合&lt;/p&gt;
							&lt;p&gt;- # Samples: 样例执行数量&lt;/p&gt;
							&lt;p&gt;- Average: 平均时间，单位: ms&lt;/p&gt;
							&lt;p&gt;- Median：中位数，50％用户的响应时间，单位: ms&lt;/p&gt;
							&lt;p&gt;- Min: 最小时间，单位: ms&lt;/p&gt;
							&lt;p&gt;- Max: 最大时间，单位: ms&lt;/p&gt;
							&lt;p&gt;- Error %: 错误率&lt;/p&gt;
							&lt;p&gt;- Throughput: 服务每秒处理的请求数据量&lt;/p&gt;
						&lt;/dd&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/dd&gt;
		&lt;/dl&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
	以上是使用过程中一些主要点的总结，我用到的功能还只是jmeter的一小部分，jmeter支持的测试类型不只HTTP请求，还有DB，junit等。本文只是介绍了一个完整测试计划的配置过程，作为一个非专业人员自己摸索，有错漏的地方，谢谢指正。
&lt;/p&gt;</content><category term="技术" /><category term="测试" /><category term="jmeter" /><summary type="html">本文就jmeter常用的、主要的功能作一个总结。</summary></entry><entry><title type="html">vue2表单验证插件のvee-validate</title><link href="http://localhost:4000/veevalidate" rel="alternate" type="text/html" title="vue2表单验证插件のvee-validate" /><published>2017-05-10T00:00:00+08:00</published><updated>2017-05-10T00:00:00+08:00</updated><id>http://localhost:4000/veevalidator</id><content type="html" xml:base="http://localhost:4000/veevalidate">&lt;p&gt;输入校验对fe来说再熟悉不过了，各种类库插件也蛮多，本文要介绍的是，基于目前很火的国人产框架Vue.js 2.0的表单验证插件 — vee-validate的常用方法，虽然&lt;a href=&quot;http://vee-validate.logaretm.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;官方API&lt;/a&gt;已经有比较详细的介绍，但有些细节还是比较隐藏的，这里分享一下&lt;/p&gt;
&lt;p&gt;还是按部就班吧，安装走起：&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	npm install vee-validate --save
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法很简单，直接引用&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	import Vue from 'vue'
	import VeeValidate from 'vee-validate'

	Vue.use(VeeValidate, {
		// 指定locale为中文
	  	locale: 'zh_CN'
	})
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以整理一个单独的组件来管理表单验证的相关代码。&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	import {Validator} from 'vee-validate'
	import cn from 'vee-validate/dist/locale/zh_CN'
	// 默认是en，这里添加中文的lang包
	Validator.addLocale(cn)
	// 自定义校验规则
	Validator.extend('chinese', {
		messages: {
			zh_CN: field =&gt; field + '格式不正确'
		},
		validate(value) {
			return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(value)
		}
	})
	// 修改vee-validate默认的提示文案
	Validator.updateDictionary({
		zh_CN: {
		    messages: {
		        regex: field =&gt; field + '格式不正确'
		    }
		}
	});
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vee-validate本身也有很多常用的校验规则可以选择，这里不累述了，直接参考&lt;a href=&quot;http://vee-validate.logaretm.com/rules.html#available-rules&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于表单控件的引用，这里有几个点：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;data-vv-as&lt;/code&gt; - 指定显示给用户看的提示字段名，默认是使用name属性&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;v-validate&lt;/code&gt; - 校验规则，多个以“|”分隔&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;data-vv-validate-on&lt;/code&gt; - 指定触发校验的时机，默认是input、change事件时触发，如希望手动触发，设置为&lt;code&gt;none&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;name&lt;/code&gt; - name属性是必须的，否则无法触发校验&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	&amp;lt;input type=&quot;text&quot; name=&quot;name&quot; data-vv-as=&quot;姓名&quot; v-validate=&quot;'required|chinese'&quot; data-vv-validate-on=&quot;blur&quot; v-model=&quot;name&quot;&amp;gt;
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是错误提示了，&lt;em&gt;errors&lt;/em&gt;的常用api如下：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;code&gt;has(field)&lt;/code&gt; - 指定字段是否有错误&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;first(field)&lt;/code&gt; - 返回指定字段的第一个错误信息&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;firstByRule(field, rule)&lt;/code&gt; - 返回指定字段某个校验规则的错误信息&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;any()&lt;/code&gt; - 当前表单校验是否有错误&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;add(file, msg, ruleRule)&lt;/code&gt; - 添加错误信息到errors对象&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;remove(field)&lt;/code&gt; - 清空指定字段的所有错误信息&lt;/li&gt;
	&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt; - 清空当前表单的所有错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p.s: name字段的校验规则包括非空和中文，这里的效果是，非空不提示错误，只有填了非中文的值才提示错误信息，如果空值需要提示，那么用first()&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	&amp;lt;div class=&quot;error&quot; v-show=&quot;errors.firstByRule('name','chinese')&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是通过data-*属性来触发校验，因为前面的&lt;code&gt;Vue.use(VeeValidate)&lt;/code&gt;已经在vue中注册了实例，也可以手动触发校验，如表单提交前手动校验：&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	this.$validator.validateAll().then(async (validateFlag) =&gt; {
        	if (!validateFlag) return
			this.$store.dispatch('showToast', {
				type: 'loading',
				message: '正在加载...'
			})
			await this.$store.dispatch('post', data)
      	}, err =&gt; {
      	})
	}
	&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里没有写校验规则，因为在控件上指定了，也可以通过js指定，那么调用就变成了&lt;code&gt;validator.validateAll()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
	&lt;code class=&quot;language-javascript&quot;&gt;
	const validator = new Validator({
		name: 'required|chinese',
		...
	})
	&lt;/code&gt;
&lt;/pre&gt;</content><category term="技术" /><category term="web" /><category term="vue" /><summary type="html">最近的项目前端是基于vue2.0，表单验证这块，用了vee-validate插件，本文是一些常用api总结。</summary></entry></feed>
